## `java`的`volatile`关键字详解

### 背景知识

> 这个关键字我们常用于多线程情况下，但是介绍这个之前我们需要聊聊这样一些知识
>
> - 原子性
>
>   > 原子操作指的就是不可以再分的操作，具有原子的量，无论是多核还是单核，同一时刻只有一个线程可以对其操作。	举个例子，
>   >
>   > - `a=0`是一个原子操作，因为我们只需要做一步，那就是给a这个内存区域进行赋值，
>   >
>   > - `a++`却不是一个原子操作，因为他可能需要两步
>   >
>   >   > 1.取出a的值(我们对a进行自增操作的话是需要获取原本a的值的)
>   >   >
>   >   > 2.进行+1操作
>   >   >
>   >   > 显然这个不是原子操作，他可以进行拆分，如果执行过了第一步，此时线程调度器选择了其他线程然后才会执行回来那么就有可能对结果有影响，也就是非原子性(出现了线程调度器中断操作的现象)
>
> - 可见性
>
>   > 一个线程对共享变量的操作，能够及时的被其他线程看到
>   >
>   > 多线程情况下，共享变量不一定可见，当然我们可以使用`synchronized volatile`来对变量修饰让其可见(`final`也可以做到，但是它初始化后的值不允许更改，所以一般不使用它实现可见性)
>
> - Java内存模型
>
>   > `Java`虚拟机试图定义一个`Java`内存模型`(java momery model JMM)`来屏蔽各种硬件和操作系统的差异，进行实现在不同平台下起到一致的内存访问效果。也就是描述了Java程序各种变量(**线程共享变量**)的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。
>   >
>   >  在Java内存模型(以下简称为JMM)中：
>   >
>   > 　　1） 所有的变量都存储在主内存中
>   >
>   > 　　2）每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）
>   >
>   > <img src="https://images2018.cnblogs.com/blog/647585/201805/647585-20180515201610136-607236613.png" alt="img" style="zoom:70%;" />
>   >
>   >  在上面的图中，可以看到线程只与工作内存交互，不能直接访问主内存。当主内存中有一个共享变量X，则工作内存则是将X拷贝，然后线程是操作工作内存中X的副本
>   >
>   >   在JMM中，有两条规定：
>   >
>   > 　　1）线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写
>   >
>   > 　　2）不同线程之间无法访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成
>   >
>   >   共享变量要实现可见性，必须经过如下两个步骤：
>   >
>   > 　　1）把工作内存1中更新过的共享变量刷新到主内存中
>   >
>   > 　　2）把主内存中最新的共享变量的值更新到工作内存2中

### 关键字讲解

> 这个关键字是`java`提供的一种比较弱的同步机制，它可以保证被修饰变量的可见性，当把变量声明为`volatile`类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。`volatile`变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取`volatile`类型的变量时总会返回最新写入的值。
>
> 在访问`volatile`变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。(这里面我们稍微看一下`ConcurrentHashMap`源码来体会它的意思)
>
> ~~~java
> //concurrentHashMap中的表，这里就是一个被volatile修饰的变量，所以我们下面在进行一些操作的时候不需要添加锁操作，因为table变量如果被修改会被及时的写入
> transient volatile Node<K,V>[] table;
> ~~~
>
> 
>
> 当对非 `volatile` 变量进行读写的时候，每个线程先从内存拷贝变量到`CPU`缓存中。如果计算机有多个`CPU`，每个线程可能在不同的`CPU`上被处理，这意味着每个线程可以拷贝到不同的` CPU cache` 中。
>
> 而声明变量是 `volatile` 的，`JVM` 保证了每次读变量都从内存中读，跳过 `CPU cache` 这一步。

**总结一下**

> 被`voltaile`修饰的变量会具备两个特性
>
> - 保证变量在不同线程之间的可见性
> - 禁止指令重排序，有`volatile`修饰的变量，赋值后多执行了一个`“load addl $0x0, (%esp)”`操作，这个操作相当于一个**内存屏障**（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个`CPU`访问内存时，并不需要内存屏障；（什么是指令重排序：是指`CPU`采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。
>
> **`volatile` 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。**

