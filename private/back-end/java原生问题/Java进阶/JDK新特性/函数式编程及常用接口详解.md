# 函数式编程

## 介绍
> 函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！

这个我借鉴与[廖雪峰官方网站](https://www.liaoxuefeng.com/wiki/1016959663602400/1017328525009056)的说法，在我这边看来，我一直这样理解函数式编程

>我们不再像命令式编程一样，使用一个确定的函数，按照他的使用规则，传入对应的参数获取一个确定的结果，也就是说调用跟行为绑定在一起，在函数式编程中是将二者划分开来，行为我们可以自己去定义，并且不是类似于之前的直接创建对象，而是只有当执行重写的方法时候才会创建
## 常用函数式接口
### Supplier
**来个例子**

```java
private static int getMax(Supplier<Integer> supplier) {
	return supplier.get();
}
```
这个方法非常简单吧，没错，不要去看函数名来猜测这个函数的作用，这个函数只是接收一个函数参数，并返回给你一个int值
~~~java
int result = getMax(() -> {
   int max = integers[0];
    for (int i = 1; i < integers.length; i++) {
        if (integers[i] > max) {
            max = integers[i];
        }
    }
    return max;
});
~~~

看到我们调用这个函数的时候会发现我们实际上传入的是一个lambda表达式，	其中包含的就是我们的一种行为，这个行为其实就是`get`方法的方法体，当然，`getMax`这个方法只需要一个`Supplier<Integer>`参数
### Consumer
~~~java
void accept(T t);

default Consumer<T> andThen(Consumer<? super T> after) {
 Objects.requireNonNull(after);
    return (T t) -> { accept(t); after.accept(t); };
}
~~~
这个接口跟我们上面的Supplier接口刚刚相反，那个是不消耗数据返回一个数据，这个是消耗一个数据而不返回，让我们来看个例子体验一下
~~~java
private static void generateMax(Consumer<Integer> consumer, List<Integer> list){
 Objects.requireNonNull(consumer);
    for (Integer integer : list) {
        consumer.accept(integer);
    }
}
public static void main(String[] args){
	Integer[] integers = new Integer[]{12,23,4,23,5,23,5,4,32};
	AtomicInteger max = new AtomicInteger();
	generateMax(one -> {
	    if(max.get() < one){
	        max.set(one);
	    }
	}, Arrays.asList(integers));
	System.out.println("max.get() = " + max.get());
}
~~~
姑且不关心`generateMax`这个方法是不是有点眼熟，我们只看他负载的内容只是一个集合遍历，然后使用调用函数的调用者给定的行为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201211124503793.png)
换成我们之前的命令式来看的的话，那是这样写的：
~~~java
private static int generateMax(Consumer<Integer> consumer, List<Integer> list) {
 Objects.requireNonNull(consumer);
    int max = 0;
    for (Integer integer : list) {
        if (max < integer) {
            max = integer;
        }
    }
    return max;
}
~~~
> 是不是这个时候体会到这种分离的感觉了，当然我这里只是展示了函数式编程的冰山一角，我们再看下其他的函数式接口
### Predicate
> 这个接口示例在我们使用Stream时候最可以体会到了，没错就是filter、anyMatch、allMatch等一系列我们是需要通过布尔值来判断的场合

**接口介绍**
~~~java
boolean test(T t);//核心方法，
//还有一些有着实现体的方法，这些我们都会在后面的例子中使用到

default Predicate<T> and(Predicate<? super T> other) {//表示调用者和传入的都需要为true
    Objects.requireNonNull(other);
    return (t) -> test(t) && other.test(t);
}
default Predicate<T> or(Predicate<? super T> other) {//表示调用者和传入的只要有一个为true
    Objects.requireNonNull(other);
    return (t) -> test(t) || other.test(t);
}
default Predicate<T> negate() {//对原有的布尔结果进行取反
 return (t) -> !test(t);
}
static <T> Predicate<T> isEqual(Object targetRef) {//用途就是判断两个参数对象是否相等，当然我们也可以使用{@link Objects#equals(Object, Object)}完成这件事
 return (null == targetRef)
            ? Objects::isNull
            : object -> targetRef.equals(object);
}
~~~
**例子**
~~~java
//对一个数组中满足我们所给条件的筛选出来
public static void main(String[] args) {
    String[] array = { "迪丽热巴,女", "古力娜扎,女", "马尔扎哈,男", "赵丽颖,女" };
    //1. 必须为女；
    //2. 姓名为4个字
    getRes(s -> s.split(",")[0].length() == 4,s -> "女".equals(s.split(",")[1]),array);

}
private static void getRes(Predicate<String> one,Predicate<String> two,String[] arr){
    for (String s : arr) {
    	//这里and表示one和two两个行为条件都需要满足，然后最终使用test方法来判断是否满足
        if(one.and(two).test(s)){
            System.out.println(s);
        }
    }
}
~~~
当然如果你使用命令编程或许会这样写
~~~java
private static void getRes(String[] arr){
 for (String s : arr) {
        if(s.split(",")[0].length() == 4 && "女".equals(s.split(",")[1])){
            System.out.println(s);
        }
    }
}
~~~
这个比较很显然，使用函数式这样的编程手段代码复用性更高一些(个人感觉还比较优雅)
### Function
**接口介绍**
> Function<T,R>
> 这个接口就是用来接收一个参数，并返回一个结果 

~~~java
R apply(T t);//核心方法
/**
这两个方法其实很简单，是作为一个链式调用的扩展
(可以参考上面函数接口的一些默认实现方法，他们都是有
异曲同工之处)，当出现有多个实现function接口的对象时候
我们需要调用他的apply方法，不用单个写，而是链式写：
o3.compose(o2).compose(o1).apply(str)
具体使用请看下面的例子
*/
default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {
  Objects.requireNonNull(before);
     return (V v) -> apply(before.apply(v));
 }
 default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {
  Objects.requireNonNull(after);
     return (T t) -> after.apply(apply(t));
 }
 //这个方法有点特殊，jdk中给出的解释是：
 //返回始终返回其输入参数的函数,实际上在我们平时的开发中用的地方还是挺少的
 //但是也有用，请看下面的例子
static <T> Function<T, T> identity() {
    return t -> t;
  }
~~~
**例子**
~~~java
//这个只是简单演示，将String经过我们传入的行为返回一个Number类型的结果
private static void numberToString(Function<String, Number> function) {
  Number apply = function.apply("12");
     System.out.println("转换结果:" + apply);
 }
 public static void main(String[] args){
 //虽然只是简单演示，但是也可以体会到他的使用方法，依旧是传递行为
	numberToString(Integer::parseInt);
	
}
~~~
**使用其他方法**
~~~java
private static void solution(Function<String, String> o1,
                                 Function<String, Integer> o2, Function<Integer, Integer> o3, String str) {
 //andThen是先执行调用者的apply方法，然后再执行传入参数的apply方法(严谨一点是从显式调用apply方法依次往后执行)
    final Integer apply = o1.andThen(o2).andThen(o3).apply(str);
    //compose是先执行传入参数的function中的apply方法，然后再执行自己的(严谨一点应该是从显式调用apply方法开始依次往前执行)
    final Integer apply1 = o3.compose(o2).compose(o1).apply(str);

    System.out.println("apply = " + apply);
    System.out.println("apply1 = " + apply1);
}
public static void main(String[] args){
	String str = "你好,20";
	//这个是两个行为，第一个就是切割字符串，第二个是将获取的结果解析为整型
    solution(s -> s.split(",")[1], Integer::parseInt, s -> s += 100, str);
}
~~~

## 总结
> 函数式接口官方提供的都在java.lang.function包下，有很多，对于我们平时的大多数业务都可以覆盖到，不过其他的接口暂时不介绍，相信如果上面的四个理解了，其他的对你也没问题，不过值得再提一次的就是函数式接口在我们的流式操作中特别常见，实际上就是因为这些函数式接口对流式操作进行极大支持，具体请参与java 8出现的Stream API(如果可以的话，其实我也推荐java 9出现的reactive stream)


