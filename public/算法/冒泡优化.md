# 冒泡优化

> 冒泡作为最基础的算法，这个思想还是很好的，衍生出了其他算法(快速排序算法的思想来源就是来自于冒泡)，这里说下对冒泡的一个简单优化



## 一：常规实现

~~~java
//      10 11 11 12 23 30  37 737
private static void bubbleSort(int[] arr) {
    if (arr == null || arr.length == 0)
        return ;
    //只需要遍历到最后一个位置的前一个位置
    for (int i = 0; i < arr.length - 1; i++) {
        //对所有的后面的数字进行判断
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[i]) {
                swap(arr, i, j);
            }
        }
    }
}
~~~

## 二：优化

- 优化一

> 优化的地方
>
> - 添加了状态变量flag,判断是否做过交换，如果没有进行交换说明后面有序就不再需要进行遍历
> - 内部循环的次数改为`length - 1 - i `,减一是因为我在内部判断大小时候是`arr[j] > arr[j + 1]`，也就是我要判断到下一位，防止出现下标越界异常，减i是因为我们每次遍历都会把最值作为一个泡上去，换句话说就是如果最大值，那么每次都会把最大的那个往上飘，那么每次遍历次数都是减一，也就是减i

~~~java
private void bubbleSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {//一共要排序size-1次
        //每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换
        int flag = 0;
        for (int j = 0; j < arr.length - 1 - i; j++) {//选出该趟排序的最大值往后移动
            if (arr[j] > arr[j + 1]) {
                int tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
                flag = 1;//只要有发生了交换，flag就置为1
            }
        }
        //判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return
        if (flag == 0) {
            return;
        }
    }
}
~~~

- 优化二

> 在每趟扫描中，记住最后一次交换发生的位置lastExchange，（该位置之后的相邻记录均已有序）。下一趟排序开始时，R[1..lastExchange-1]是无序区，R[lastExchange..n]是有序区。这样，一趟排序可能使当前无序区扩充多个记录，因此记住最后一次交换发生的位置lastExchange，从而减少排序的趟数。

~~~java
private void bubbleSort3(int[] arr) {
    int k = arr.length - 1, pos = 0;//pos变量用来标记循环里最后一次交换的位置

    for (int i = 0; i < arr.length - 1; i++) {//一共要排序size-1次
        //每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换
        int flag = 0;
        for (int j = 0; j < k; j++) {//选出该趟排序的最大值往后移动
            if (arr[j] > arr[j + 1]) {
                int tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
                flag = 1;//只要有发生了交换，flag就置为1
                pos = j;//循环里最后一次交换的位置 j赋给pos
            }
        }
        k = pos;
        //判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return
        if (flag == 0) {
            return;
        }
    }
}
~~~

