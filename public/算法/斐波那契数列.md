# 斐波那契数列

## 一：数列简单介绍

> 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
>
> `F(0) = 0，F(1) = 1
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1`
>
> 通常都是需要让我们来计算F(n)，也就是第n项

## 二：求法

- 常规递归求法

~~~java
//这时候斐波那契额数列使用递归就会显得性能降低，他重复计算太多，并且随着n的不断增大性能越低
private int fi(int n) {
    if (n <= 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fi(n - 1) + fi(n - 2);
    }
}
~~~

我们来看一个图查看他的计算流程（随便在网络上搜索了一个图）

![img](https://pic1.zhimg.com/80/v2-a8585da63e66320469a6c4e6745828f0_1440w.jpg)

> 我们发现当n==5时候，递归的计算流程：
>
> - 计算n == 4 与n == 3
> - 计算n == 3 与 n == 2 与n == 2 与n == 1
> - 计算n == 2 与n == 1
> - 计算n == 1
>
> 这样的话一目了然，n==3计算了不止一次，n == 2或n == 1也是，这样的话对效率有了很大的影响，这时候n == 5，如果计算的n变得大的话对效率有着明显的影响

- 所以这里暂时不采用递归求法

~~~java
private long fiOptimize(int n) {
    int[] result = {0, 1};
    if (n < 2) {
        return result[n];
    }
    //one变量就是第一个，two是计算的第二个变量，fin是他们加和
    long one = 1, two = 0, fin = 0;
    for (int i = 2; i <= n; i++) {
        fin = one + two;
        two = one;
        one = fin;
    }
    return fin;
}
~~~

- 不代表使用递归不可以，只是说我们需要对递归进行优化一下，优化的思路就是让他不再重复计算，我们将每次计算的结果值保存起来

~~~java
//改进的递归方式
private long fiImprove(int n) {
    long[] fib = new long[256];
    fib[1] = 1;
    if (n == 0) {
        return 0;
    }
    if (fib[n] != 0) {
        return fib[n];
    }
    //这里对fib[n]进行赋值，相当于每次计算下来之后都会保存，然后返回对应的n对应数组中的值就可以
    //这里跟直接return fiImprove(n - 1) + fiImprove(n - 2);有着不同的含义，一个将结果值保存到fib数组中，一个是没有保存而是直接返回
    fib[n] = fiImprove(n - 1) + fiImprove(n - 2);
    return fib[n];
}

~~~

三：总结

> 这个例子主要想说明不是这个数列，而是递归与循环，如果一个递归没有跳出的位置，那就相当于一个死循环，很多时候我们需要思考使用哪一个，递归看着有逼格，但是可能是要付出代价，所以我们还是根据实际场景来使用计算方法，考虑角度就是从时间和空间两个角度思考